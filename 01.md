# awk是什么
awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。

# 简单使用
首先介绍几个简单的实例，以便大家有个直观的了解。
有如下的基金历史数据，存储在文件(000962.txt)[000962.txt]内，共有20行数据，每行有4个字段。
```
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
10    2015-12-14    1.1818    1.1818
11    2015-12-11    1.1599    1.1599
12    2015-12-10    1.1685    1.1685
13    2015-12-09    1.1719    1.1719
14    2015-12-08    1.1774    1.1774
15    2015-12-07    1.2080    1.2080
16    2015-12-04    1.1941    1.1941
17    2015-12-03    1.2028    1.2028
18    2015-12-02    1.1778    1.1778
19    2015-12-01    1.1838    1.1838
20    2015-11-30    1.1784    1.1784
```

如果我们想取得第3列数据大于1.2的结果，可以如下处理
```$ awk '$3>1.2' 000962.txt ```

```
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
15    2015-12-07    1.2080    1.2080
17    2015-12-03    1.2028    1.2028
```

那我们如果只需要返回日期和基金净值呢：
```$ awk '$3>1.2{print $2,$3}' 000962.txt```
```
2015-12-25 1.2366
2015-12-24 1.2296
2015-12-23 1.2324
2015-12-22 1.2454
2015-12-21 1.2351
2015-12-18 1.2218
2015-12-17 1.2247
2015-12-07 1.2080
2015-12-03 1.2028
```

如果我们需要在每行前加上行号的话，可以这样：
`$ awk 'BEGIN{NM=0;} $3>1.2{NM+=1;print NM,$2,$3}' 000962.txt `
> 1 2015-12-25 1.2366
2 2015-12-24 1.2296
3 2015-12-23 1.2324
4 2015-12-22 1.2454
5 2015-12-21 1.2351
6 2015-12-18 1.2218
7 2015-12-17 1.2247
8 2015-12-07 1.2080
9 2015-12-03 1.2028

# 记录和字段
从上面几个例子里，有涉及到记录和字段的概念，如果你已经很熟悉了，此段可以略过。
一条记录可以粗略的理解为一行。字段是一行里彼此分开的数据段，每个段就是一个字段。
比如如下数据：

> AAA  111
BBB 222
CCC 333
DDD 444

我们称为有4条记录，每条记录有3个字段。这里有一个默认的规则，及记录与记录之间是换行符分割的，字段与字段之间是通过空格分割的。
所以， 如上的记录也可以表示为:
> AAA+111
BBB+222
CCC+333
DDD+444

这里采用了默认的记录分隔符（换行符），而没有采用默认的字段分隔符（空格），而是使用了加好（+），这都是允许的。

所以对于上面提到的话，『一条记录可以粗略的理解为一行』，这里粗略就是默认的换行符。当记录分隔符不是换行符的情况下，一行数据可能代表的就是多条记录，这取决于我们对于数据的理解。
如

> AAA+111|BBB+222|CCC+333|DDD+444

这个也可以表示成上述数据的第三种格式。
如果我们需要把第三种数据输出成第一种，也是可以做到的。
`$ echo 'AAA+111|BBB+222|CCC+333|DDD+444'|awk 'BEGIN{FS=+";RS="|"}{print $1, $2}' `
>AAA 111
BBB 222
CCC 333
DDD 444

(FS--field separator, RS--recod separator)

所以对于数据的解读，取决于我们对于记录分隔符和字段分隔符的定义。这两个值对于awk来说，也是可以自定义的。

# awk处理流程
awk处理的大致流程，就是以记录分隔符将文本切分成记录，然后再对每条记录以字段分隔符为准，切分成字段，再把这些值转换成简单的变量给到程序处理。

进过以上处理之后，$0代表的就是单条的记录，$1~$n代表的就是当前行的字段，n表示当前行的最后一个字段值。

我们所写的代码会重复的执行，会从第一条到最后一条记录。$0的值是变动的，指示的是当前的行，在当前行上你是没有办法直接拿到上一行数据的，除非你自己保存了上行数据，你是没有办法拿到当前行下一行数据的，你能做的就是处理完这行或跳过这行，等待下一行的来临。

除了按行处理流程，awk还定义了BEGIN和END块。BEGIN块在处理所有行之前执行，END块在处理完所有行后执行。
$ awk 'BEGIN{print "beggin...";NM=0;SUM=0;}{NM+=1;SUM+=$3;print;} END{print "average is:",SUM/NM}' 000962.txt
beggin...
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
... ... ... ... 
19    2015-12-01    1.1838    1.1838
20    2015-11-30    1.1784    1.1784
average is: 1.20086

# 字段的处理


# 字段运算
# 查找
