# awk是什么
awk其名称来自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。
实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。
它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能。

# 简单使用
首先介绍几个简单的实例，以便大家有个直观的了解。
有如下的基金历史数据，存储在文件[000962.txt](awk/000962.txt)内，共有20行数据，每行有4个字段。
这里列出了前9行的数据。
```
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
8    2015-12-16    1.1965    1.1965
9    2015-12-15    1.1906    1.1906
```

如果我们想取得第3列数据大于1.2的结果，可以如下处理
```
$ awk '$3>1.2' 000962.txt 

1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
3    2015-12-23    1.2324    1.2324
4    2015-12-22    1.2454    1.2454
5    2015-12-21    1.2351    1.2351
6    2015-12-18    1.2218    1.2218
7    2015-12-17    1.2247    1.2247
15    2015-12-07    1.2080    1.2080
17    2015-12-03    1.2028    1.2028
```

那我们如果只需要返回日期和基金净值呢：
```
$ awk '$3>1.2{print $2,$3}' 000962.txt

2015-12-25 1.2366
2015-12-24 1.2296
2015-12-23 1.2324
2015-12-22 1.2454
2015-12-21 1.2351
2015-12-18 1.2218
2015-12-17 1.2247
2015-12-07 1.2080
2015-12-03 1.2028
```

如果我们需要在每行前加上行号的话，可以这样：
```
$ awk 'BEGIN{NM=0;} $3>1.2{NM+=1;print NM,$2,$3}' 000962.txt

1 2015-12-25 1.2366
2 2015-12-24 1.2296
3 2015-12-23 1.2324
4 2015-12-22 1.2454
5 2015-12-21 1.2351
6 2015-12-18 1.2218
7 2015-12-17 1.2247
8 2015-12-07 1.2080
9 2015-12-03 1.2028
```

# 记录和字段
从上面几个例子里，有涉及到记录和字段的概念，如果你已经很熟悉了，此段可以略过。

一条记录可以粗略的理解为一行。字段是一行里彼此分开的数据段，每一段就是一个字段值。
比如如下数据：

```
AAA 111
BBB 222
CCC 333
DDD 444
```

我们称为有4条记录，每条记录有3个字段。
这里有一个规则，就是我们默认为记录与记录之间是通过换行符分割的，字段与字段之间是通过空格分割的。

所以， 只要改变其中的一个规则，我们可以把上述数据表示为一下格式:
```
AAA+111
BBB+222
CCC+333
DDD+444
```
这里采用了默认的记录分隔符 --- 换行符，而没有采用默认的字段分隔符 --- 空格，而是使用了加号（+），规则是我们自己定义的。

所以对于上面提到的，『一条记录可以粗略的理解为一行』，这里的粗略就是指默认的记录分隔符---换行符。
当记录分隔符不是换行符的情况时，一行数据可能代表的就是多条记录，这取决于我们对于数据的理解。

```
AAA+111|BBB+222|CCC+333|DDD+444
```
这个也可以表示成上述数据的第三种格式。
如果我们需要把第三种数据输出成第一种，也是可以做到的。

```
$ echo 'AAA+111|BBB+222|CCC+333|DDD+444'|awk 'BEGIN{FS=+";RS="|"}{print $1, $2}'

AAA 111
BBB 222
CCC 333
DDD 444
```
这里我们使用到了AWK支持的两个参数FS和RS。FS是field separator的缩写，称为字段分隔符。 
RS是recod separator的缩写，称为记录分隔符。

所以对于数据的解读，取决于我们对于记录分隔符和字段分隔符的定义。
只需要把规则告诉AWK,它就能给你想要的。

在AWK的处理过程中，我们可以通过`$0`来表示当前记录，用$1代表第一个字段，一直到$n,n就是当前记录的字段总数。

# awk处理流程
awk处理的大致流程，就是以记录分隔符将文本切分成记录，
然后再对每条记录以字段分隔符为准，切分成字段，再把这些值转换成变量给到程序处理。

经过AWK的处理处理之后，`$0`代表的就是整个单条的记录，`$1~$n`代表的就是当前行的字段，`$n`表示当前行的最后一个字段值。
AWK重复的执行代码，输入就是每行，一直到最后一条记录。

`$0`的值是变动的，指示的是当前的行，在当前行上你是没有办法直接拿到上一条数据的，除非你自己保存了上行数据；
同样你也是没有办法拿到下一条数据的，你能做的就是处理完这条记录或跳过这条，等待下一条的来临。

除了按记录处理流程，awk还定义了BEGIN和END块。
BEGIN块在处理所有记录之前执行，END块在处理完所有记录后执行。

```
$ awk 'BEGIN{print "beggin...";NM=0;SUM=0;}{NM+=1;SUM+=$3;print;} END{print "average is:",SUM/NM}' 000962.txt

beggin...
1    2015-12-25    1.2366    1.2366
2    2015-12-24    1.2296    1.2296
... ... ... ... 
19    2015-12-01    1.1838    1.1838
20    2015-11-30    1.1784    1.1784
average is: 1.20086
```
为了避免输出结果占用过多的篇幅，中间部分用省略号做了替代。

> 第二份数据,[tcp连接报告](awk/tcp.txt)。
```
tcp4       0      0  192.168.1.103.50660    17.250.120.76.443      FIN_WAIT_1
tcp4       0      0  192.168.1.103.50655    74.125.23.138.443      SYN_SENT
tcp4       0      0  192.168.1.103.50654    74.125.23.139.443      SYN_SENT
tcp4       0      0  192.168.1.103.50653    74.125.23.100.443      SYN_SENT
tcp4       0      0  192.168.1.103.50652    74.125.23.100.443      SYN_SENT
tcp4       0      0  192.168.1.103.50646    202.108.249.252.80     CLOSE_WAIT
tcp4       0      0  192.168.1.103.50645    202.108.249.252.80     CLOSE_WAIT
tcp4       0      0  192.168.1.103.50644    202.108.249.252.80     CLOSE_WAIT
tcp4       0      0  192.168.1.103.50643    202.108.249.252.80     CLOSE_WAIT
tcp4       0      0  192.168.1.103.50642    111.202.60.47.80       LAST_ACK
tcp4       0      0  192.168.1.103.50547    198.41.215.67.80       LAST_ACK
tcp4       0      0  192.168.1.103.49779    209.20.75.76.80        CLOSE_WAIT%
```

# 字段的处理
获取所有的本地打开的端口以及端口的连接状态。
```
$ cat awk/tcp.txt|awk '{print substr($4,15), $6;}'
50660 FIN_WAIT_1
50655 SYN_SENT
50654 SYN_SENT
50653 SYN_SENT
50652 SYN_SENT
50646 CLOSE_WAIT
50645 CLOSE_WAIT
50644 CLOSE_WAIT
50643 CLOSE_WAIT
50642 LAST_ACK
50547 LAST_ACK
49779 CLOSE_WAIT
```

# 表达式
AWK的表达式由两`pattern`和`action`组成，`pattern { action } `组成。
省略`pattern`表示匹配所有行，`{action}`是可以省略的，表示打印整个行。

pattern-action直接可以通过换行或分号进行分割。

`action`表示的是一个表达式序列，一个表达式可以由以下部分组成：
```
if( expression ) statement [ else statement ]
while( expression ) statement
for( expression ; expression ; expression ) statement
for( var in array ) statement
do statement while( expression )
break
continue
{ [ statement ... ] }
expression              # commonly var = expression
print [ expression-list ] [ > expression ]
printf format [ , expression-list ] [ > expression ]
return [ expression ]
next                    # skip remaining patterns on this input line
nextfile                # skip rest of this file, open next, start at top
delete array[ expression ]# delete an array element
delete array            # delete all elements of array
exit [ expression ]     # exit immediately; status is expression
```

# 内置常量
- `CONVFMT`
- `FS` 字段分隔符，值是一个正则表达式
- `NF` 当前记录的字段总个数
- `NR`  当前记录的顺序号
- `FNR` 当前记录位于当前文件的顺序号，处理多个文件的时候有用
- `FILENAME`    当前文件名
- `RS`  记录分隔符，默认为换行符
- `OFS` 指定以怎样的分隔符为输出数据的字段分隔符，默认为空格
- `ORS` 输出记录分隔符，默认为换行
- `OFMT` 输出顺序号的格式,默认为 0.6g
- `SUBSEP`
- `ARGC`
- `ARGV`
- `ENVIRON`

# 内置函数
- `length` 把参数值当做字符串所占有的长度,如果没有指定参数默认为当前记录的总长度
- `srand` 设置随机谁的种子
- `rand` 返回0~1之间的一个随机数
- `int` 转换字符串成数值类型
- `substr(s, m, n)`
- `index(s, t)`
- `match(s, r)`
- `split(s, a, fs)`
- `sub(r, t, s)`
- `gsub`
- `sprintf`
- `system(cmd)`
- `tolower(str)`
- `toupper(str)`

